--------------- Ontology (pretty sure that's how it's called) ------------------
Node = {
    id,
    title,
    parentRelationShip (->I like this one because with one property you access it, and it s up to contech os to resolve it. Not sure how hard is it to implement though)
    childrenRelationShips (-> same as above)
    sameLevelRelationships ()
    customProperties (An array. we don't use them but there would go the user defined props of the node, like a password for a user node, that would be a direct prop of the node and not related to it)
    (layer)
}

Relationship = {
    id,
    title,
    parentRelationShip
    childrenRelationShips
    source
    target
    (layer)
}

--------------- Considerations -----------------------
GraphQl mention gzip, very good at compressing json. it oculd be a way to optimize big requests.
I don't think it's handled by graphql tho, we would have to add the compression system manually.

A Layer node --> I am not sure about this one as it doesn't really have any specific data,
It might be a good entry point for requests.
It might also be useful to init database from request --> would be nice if you could copy any contechOS just by querying layer(depth: [0,1] for example.
It would look like that:
Layer = {
    parent,
    child,
    node,
    relation
}

Having the parent, children and same level relationships properties allow to explore the graph without any knowldege of the db structure.

From what I know id are semi-randomly generated (meaningful prefix followed by random key),
and if I manually recreate a db with the same structure ids will differs from the original, leading to the need of updating .env and possibly other things.
If we make our requests are based on the relation title instead we avoid all that, we can clone databases, they all have their own ids and we don't care.
Sharing ids across databases would not be a good idea either: you would have conflict for example when importing foreign into your db.
Meaningful relationship title would be as simple as isProfileToProject for example. Formulating this way also clarify whose the target and whose the source.

The way data is stored, nodes objects are ignorants of relations tying them. I expected to be the same for parent relation but no, the node directly holds its parentId.

--------------- Examples ---------------------------

Request to get one specific node:
{
    nodes(id: $td_gghjgglugqggbl)
}

    response:
        { nodes: [
            {node object}
        ]}

Request to get all nodes:
{
    nodes
}
    response:
            { nodes: [
                {node object},
                {node object},
                {node object},
                {node object}
                ...
            ]}

Request to get parentNode id:
{
    nodes:(id: $td_jhbhjhbjh) {
        parentRel {
            target(sourceID: td_jhbhjhbjh) {
                id
            }
        }
    }
}

    Response:
    { nodes: [
        { parentRel : {
                target: {
                    id: fr_jhbhjvlvlvulvghv
                }
            }
        }
    ]}

Request to get all the profiles linked to one project:
{
    projectnode: nodes(id: $profile_id) {
        profileToProjects: sameLevelRelations(parentId: $profileRelationParentId) {
            source
        }
    }
}

    Response:
    { nodes: [
            { projectnode: {
                profileToProjectRelation: [
                    {profileObject},
                    {profileObject},
                    {profileObject}
                ]}
            }
        ]}